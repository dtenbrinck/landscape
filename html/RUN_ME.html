
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>RUN_ME</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-06-20"><meta name="DC.source" content="RUN_ME.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">initialization</a></li><li><a href="#3">load and preprocess data</a></li><li><a href="#4">estimate shape of embryo from DAPI channel</a></li><li><a href="#5">Little excurse to the dimensions</a></li><li><a href="#6">Estimate embryo shape by fitting ellipsoid to sharp areas</a></li><li><a href="#7">Segment GFP landmark</a></li><li><a href="#8">experimental code for rescaling data with different sizes</a></li><li><a href="#9">segment stem cells in mCherry channel</a></li><li><a href="#10">transform GFP on embryo shape onto unit sphere</a></li><li><a href="#11">experimental code for meshgrid with different resolution</a></li><li><a href="#12">create a meshgrid with same resolution as data</a></li><li><a href="#13">experimental code to transform data using ellipsoid equation</a></li><li><a href="#14">specify transformation matrix based on orientation and length of axis</a></li><li><a href="#15">experimental code for sampling unit cube as 3D voxel grid</a></li><li><a href="#16">sample surface of unit sphere by parametrization</a></li><li><a href="#17">transform segmented cells on new positions within unit sphere</a></li><li><a href="#18">Registration</a></li><li><a href="#20">visualize results</a></li></ul></div><pre class="codeinput"><span class="comment">% Main script for registration of confocal microscopy data of small fish</span>
<span class="comment">% embryos.</span>
<span class="comment">%</span>
<span class="comment">% Data: We assume the data to be already converted from *.STK files given</span>
<span class="comment">% by the biologists to *.mat files containing a struct with three fields:</span>
<span class="comment">% data</span>
<span class="comment">%     .Dapi    -&gt; fluorescence of nuclei near the embryo membrane</span>
<span class="comment">%     .GFP     -&gt; fluorescence of anatomic structure denoted as 'landmark'</span>
<span class="comment">%     .mCherry -&gt; fluorescence of labeled stem cells in embryo</span>
<span class="comment">%</span>
<span class="comment">% One is interested in the distribution of the cells in the mCherry data.</span>
<span class="comment">% We use the information in the Dapi channel to estimate the shape of the</span>
<span class="comment">% embryo and the landmark in the GPF channel for registration of different</span>
<span class="comment">% specimen.</span>
<span class="comment">%</span>
<span class="comment">%   Copyright: Daniel Tenbrinck</span>
<span class="comment">%   Department of Mathematics and Computer Science</span>
<span class="comment">%   University of Muenster, Germany</span>
<span class="comment">%   email: daniel.tenbrinck@wwu.de</span>
</pre><h2>initialization<a name="2"></a></h2><pre class="codeinput"><span class="comment">% tidy up memory and windows before starting</span>
clear; close <span class="string">all</span>; clc;

<span class="comment">% get all subdirectories</span>
addpath(genpath(pwd));
</pre><h2>load and preprocess data<a name="3"></a></h2><pre class="codeinput"><span class="comment">% load the data</span>
load(<span class="string">'1.mat'</span>);

<span class="comment">% set rescaling factor</span>
scale = 0.5;

<span class="comment">% set resolution for data in micrometers (given by biologists)</span>
resolution = [1.29/scale, 1.29/scale, 20];

<span class="comment">% rescale data for higher processing speed using trilinear interpolation</span>
<span class="keyword">for</span> i=1:size(data.Dapi,3)
  dapi_resized(:,:,i) = imresize(data.Dapi(:,:,i), scale);
  gfp_resized(:,:,i) = imresize(data.GFP(:,:,i), scale); <span class="comment">% coarse data for segmentation sufficient</span>
  mCherry_resized(:,:,i) = imresize(data.mCherry(:,:,i), scale);
<span class="keyword">end</span>

<span class="comment">% normalize data</span>
dapi_resized = normalizeData(dapi_resized);           <span class="comment">% nuclei in embryo membrane</span>
gfp_resized = normalizeData(gfp_resized);             <span class="comment">% landmark</span>
mCherry_resized = normalizeData(mCherry_resized);     <span class="comment">% labeled cells</span>
</pre><h2>estimate shape of embryo from DAPI channel<a name="4"></a></h2><pre class="codeinput"><span class="comment">% generate three-dimensional Gaussian filter</span>
g = generate3dGaussian(9, 1.5);

<span class="comment">% denoise DAPI channel by blurring</span>
blurred = imfilter(dapi_resized, g, <span class="string">'same'</span>,<span class="string">'replicate'</span>);

<span class="comment">% generate a three-dimensional Laplacian filter</span>
kernelLaplace = generate3dLaplacian(resolution);

<span class="comment">% determine sharp areas in DAPI channel by Laplacian filtering</span>
sharp_areas = normalizeData (imfilter(blurred, kernelLaplace, <span class="string">'same'</span>, <span class="string">'replicate'</span>));
</pre><h2>Little excurse to the dimensions<a name="5"></a></h2><p>The image is always set in [row, column, z] dimensionsen. When we are working with axis [x,y,z] x = column, y = row and z = z. fitEllipsoid is working on the axis. So we get a center and a radii that depends on the axis and not on the image itself. So if we compute a sphere in the axis we can just use center and radii as it is. but if we want to visualize it in the image we need to permute the dimensions. So we can just work with the the output of fitEllipsoid on our sphere etc. But we need to be carefull when we use interp3 with landmark. landmark is the segmentation of the gfp channel. So it is in the same dimensions as the other images. We dont need to care about the resolution now because it is the same for x and y. centCoords gives us the centroids of the cells in the image. It is computed with regionprops. This gives us the right centroids with the right order. So we can just use it for our axial representation.</p><h2>Estimate embryo shape by fitting ellipsoid to sharp areas<a name="6"></a></h2><pre class="codeinput">[center radii axes v] = fitEllipsoid(sharp_areas, resolution);
</pre><h2>Segment GFP landmark<a name="7"></a></h2><pre class="codeinput">landmark = segmentGFP(gfp_resized, resolution);
</pre><pre class="codeoutput">Optimal threshold for GFP embryo data computed as t1=1.520000e-01.
Optimal threshold for GFP landmark computed as t2=3.000000e-01.
</pre><h2>experimental code for rescaling data with different sizes<a name="8"></a></h2><p>(some channel work with even less resolution)</p><pre class="codeinput"><span class="comment">% % delete old variable</span>
<span class="comment">% clear gfp_resized;</span>
<span class="comment">% % rescale gfp data and gfp landmark to higher resolution</span>
<span class="comment">% for i=1:size(data.Dapi,3)</span>
<span class="comment">%  landmark(:,:,i) = imresize(landmark_resized(:,:,i), size(dapi_resized(:,:,1)), 'nearest');</span>
<span class="comment">%  gfp_resized(:,:,i) = imresize(data.GFP(:,:,i), scale);</span>
<span class="comment">% end</span>
</pre><h2>segment stem cells in mCherry channel<a name="9"></a></h2><pre class="codeinput"><span class="comment">% segment cells</span>
[cells,centCoords] = segmentCells( mCherry_resized, resolution );
</pre><pre class="codeoutput">Optimal threshold for embryo data in mCherry channel computed as t1=2.627451e-01.
</pre><h2>transform GFP on embryo shape onto unit sphere<a name="10"></a></h2><pre class="codeinput"><span class="comment">% sample original space</span>
mind = [0 0 0]; maxd = size(landmark) .* resolution;
</pre><h2>experimental code for meshgrid with different resolution<a name="11"></a></h2><pre class="codeinput"><span class="comment">%nsteps = maxd*0.2;</span>
<span class="comment">%step = ( maxd - mind ) ./ nsteps;</span>
<span class="comment">%[ X, Y, Z ] = meshgrid( linspace( mind(2) - step(2), maxd(2) + step(2), nsteps(2) ), linspace( mind(1) - step(1), maxd(1) + step(1), nsteps(1) ), linspace( mind(3) - step(3), maxd(3) + step(3), nsteps(3) ) );</span>
</pre><h2>create a meshgrid with same resolution as data<a name="12"></a></h2><pre class="codeinput">[ X, Y, Z ] = meshgrid( linspace( mind(2), maxd(2), size(landmark,2) ), linspace( mind(1), maxd(1), size(landmark,1) ), linspace( mind(3), maxd(3), size(landmark,3) ) );
</pre><h2>experimental code to transform data using ellipsoid equation<a name="13"></a></h2><p>[ x_coarse, y_coarse, z_coarse] = meshgrid( linspace( mind(2) - step(2), maxd(2) + step(2), size(landmark,2) ), linspace( mind(1) - step(1), maxd(1) + step(1), size(landmark,1) ), linspace( mind(3) - step(3), maxd(3) + step(3), size(landmark,3) ) ); Ellipsoid = v(1) *X.*X +   v(2) * Y.*Y + v(3) * Z.*Z + ...     2*v(4) *X.*Y + 2*v(5)*X.*Z + 2*v(6) * Y.*Z + ...     2*v(7) *X    + 2*v(8)*Y    + 2*v(9) * Z -1; % interpolate data landmark_fine = interp3(x_coarse, y_coarse, z_coarse, landmark, X, Y, Z, 'nearest');</p><pre class="codeinput"><span class="comment">%validGFP = landmark_fine .* (abs(Ellipsoid) &lt; 0.01);</span>
<span class="comment">% visualize and save result in 3D</span>
<span class="comment">%renderGFPsurface(Ellipsoid, landmark_fine, [1 1 1],X,Y,Z)</span>
</pre><h2>specify transformation matrix based on orientation and length of axis<a name="14"></a></h2><pre class="codeinput">scale_matrix = eye(3);
scale_matrix(1) = 1/radii(1);
scale_matrix(5) = 1/radii(2);
scale_matrix(9) = 1/radii(3);
rotation_matrix = axes';
transform = scale_matrix * rotation_matrix;
</pre><h2>experimental code for sampling unit cube as 3D voxel grid<a name="15"></a></h2><pre class="codeinput"><span class="comment">%mind = [-1 -1 -1]; maxd = [1 1 1];</span>
<span class="comment">%nsteps = [64 64 64];</span>
<span class="comment">%step = ( maxd - mind ) ./ nsteps;</span>
<span class="comment">%[Xc Yc Zc] = meshgrid( linspace( mind(2) - step(2), maxd(2) + step(2), nsteps(2) ), linspace( mind(1) - step(1), maxd(1) + step(1), nsteps(1) ), linspace( mind(3) - step(3), maxd(3) + step(3), nsteps(3) ));</span>
</pre><h2>sample surface of unit sphere by parametrization<a name="16"></a></h2><pre class="codeinput">samples = 64;
[alpha, beta] = meshgrid(linspace(pi,2*pi,samples/2), linspace(0,2*pi,samples)); <span class="comment">% TODO: only one time 2*pi!</span>
Zs = cos(alpha) .* sin(beta);
Xs = sin(alpha) .* sin(beta);
Ys = cos(beta);

<span class="comment">% determine position of spherical points in original space</span>

[Xs_t,Ys_t,Zs_t] = transformUnitSphere3D(Xs,Ys,Zs,scale_matrix,rotation_matrix,center);

<span class="comment">% interpolate signal on unit sphere transformed to original space</span>
GFPOnSphere = interp3(X, Y, Z, landmark, Xs_t, Ys_t, Zs_t,<span class="string">'nearest'</span>);
</pre><h2>transform segmented cells on new positions within unit sphere<a name="17"></a></h2><pre class="codeinput"><span class="comment">% sample unit cube as 3D voxel grid</span>
[Xc, Yc, Zc] = meshgrid(linspace(-1,1,samples), linspace(-1,1,samples), linspace(-1,1,samples));

<span class="comment">% determine position of points in unit cube in original space</span>

[Xc_t,Yc_t,Zc_t] = transformUnitCube3D(Xc,Yc,Zc,scale_matrix,rotation_matrix,center);

<span class="comment">% interpolate signal in unit cube transformed to original space</span>

CellsInSphere = interp3(X, Y, Z, cells, Xc_t, Yc_t, Zc_t,<span class="string">'nearest'</span>);
CellsInSphere(isnan(CellsInSphere)) = 0;
</pre><h2>Registration<a name="18"></a></h2><pre class="codeinput"><span class="comment">% Get coordinates of the cells</span>

<span class="comment">% Fit Coordinates to real resolution</span>

centCoords = diag(resolution)*centCoords;

<span class="comment">% Transform the coordinates into the sphere. With scaling and rotating.</span>
centCoords(1,:) = centCoords(1,:)-center(1);
centCoords(2,:) = centCoords(2,:)-center(2);
centCoords(3,:) = centCoords(3,:)-center(3);
centCoords = transform*centCoords;


<span class="comment">% Regression</span>

data = [(round(Xs(GFPOnSphere == 1 &amp; Zs &lt;= 0)*10^10)/10^10)';<span class="keyword">...</span>
    (round(Ys(GFPOnSphere == 1 &amp; Zs &lt;= 0)*10^10)/10^10)';<span class="keyword">...</span>
    (round(Zs(GFPOnSphere == 1 &amp; Zs &lt;= 0)*10^10)/10^10)'];
data = unique(data',<span class="string">'rows'</span>)';
[pstar,vstar] = sphericalRegression3D(data,[11;0;0],[0;0;-1]);
</pre><pre class="codeoutput error">Error using sqpLineSearch
Objective function is undefined at initial point. Fmincon cannot continue.

Error in fmincon (line 807)
    [X,FVAL,EXITFLAG,OUTPUT,LAMBDA,GRAD,HESSIAN] = sqpLineSearch(funfcn,X,full(A),full(B),full(Aeq),full(Beq), ...

Error in sphericalRegression3D (line 46)
pvstar = fmincon(F,pv0,[],[],[],[],[],[],nonlcon,options);

Error in RUN_ME (line 193)
[pstar,vstar] = sphericalRegression3D(data,[11;0;0],[0;0;-1]);
</pre><div><ol><li>ITEM1</li><li>ITEM2</li></ol></div><pre class="codeinput"><span class="comment">% Registration and transformation</span>
</pre><h2>visualize results<a name="20"></a></h2><pre class="codeinput">figure;
renderCellsInSphere(CellsInSphere,Xc,Yc,Zc);
hold <span class="string">on</span>;
T = 0:0.01:1;
    G = geodesicFun(pstar,vstar);
    regressionLine = G(T);
    scatter3(pstar(1),pstar(2),pstar(3));

    quiver3(pstar(1),pstar(2),pstar(3),vstar(1)/norm(vstar),vstar(2)/norm(vstar),vstar(3)/norm(vstar));
    plot3(regressionLine(1,:),regressionLine(2,:),regressionLine(3,:),<span class="string">'r'</span>);
    plot3(data(1,1),data(2,1),data(3,1),<span class="string">'o'</span>)
    plot3(data(1,end),data(2,end),data(3,end),<span class="string">'o'</span>)
    xlim([-1,1]);
    ylim([-1,1]);
    zlim([-1,1]);
    <span class="comment">%plot3(x,y,z);</span>
    scatter3(data(1,:),data(2,:),data(3,:),<span class="string">'*'</span>)

grid <span class="string">on</span>;
scatter3(centCoords(1,:),centCoords(2,:),centCoords(3,:));
scatter3(Xs(:), Ys(:), Zs(:),10,[0 1 0]);
scatter3(Xs(GFPOnSphere == 1 &amp; Zs &lt;= 0), Ys(GFPOnSphere == 1 &amp; Zs &lt;= 0), Zs(GFPOnSphere == 1 &amp; Zs &lt;= 0),50,[1 0 0]);
hold <span class="string">off</span>;
axis <span class="string">vis3d</span> <span class="string">equal</span>;
view([-37.5, -75])
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
% Main script for registration of confocal microscopy data of small fish
% embryos.
%
% Data: We assume the data to be already converted from *.STK files given
% by the biologists to *.mat files containing a struct with three fields:
% data
%     .Dapi    -> fluorescence of nuclei near the embryo membrane
%     .GFP     -> fluorescence of anatomic structure denoted as 'landmark'
%     .mCherry -> fluorescence of labeled stem cells in embryo
%
% One is interested in the distribution of the cells in the mCherry data.
% We use the information in the Dapi channel to estimate the shape of the
% embryo and the landmark in the GPF channel for registration of different
% specimen.
%
%   Copyright: Daniel Tenbrinck
%   Department of Mathematics and Computer Science
%   University of Muenster, Germany
%   email: daniel.tenbrinck@wwu.de
%   $Date: 2016/02/18 $

%% initialization

% tidy up memory and windows before starting
clear; close all; clc;

% get all subdirectories
addpath(genpath(pwd));

%% load and preprocess data

% load the data
load('1.mat');

% set rescaling factor
scale = 0.5;

% set resolution for data in micrometers (given by biologists)
resolution = [1.29/scale, 1.29/scale, 20];

% rescale data for higher processing speed using trilinear interpolation
for i=1:size(data.Dapi,3)
  dapi_resized(:,:,i) = imresize(data.Dapi(:,:,i), scale);
  gfp_resized(:,:,i) = imresize(data.GFP(:,:,i), scale); % coarse data for segmentation sufficient
  mCherry_resized(:,:,i) = imresize(data.mCherry(:,:,i), scale);
end

% normalize data
dapi_resized = normalizeData(dapi_resized);           % nuclei in embryo membrane
gfp_resized = normalizeData(gfp_resized);             % landmark
mCherry_resized = normalizeData(mCherry_resized);     % labeled cells

%% estimate shape of embryo from DAPI channel

% generate three-dimensional Gaussian filter
g = generate3dGaussian(9, 1.5);

% denoise DAPI channel by blurring
blurred = imfilter(dapi_resized, g, 'same','replicate');

% generate a three-dimensional Laplacian filter
kernelLaplace = generate3dLaplacian(resolution);

% determine sharp areas in DAPI channel by Laplacian filtering
sharp_areas = normalizeData (imfilter(blurred, kernelLaplace, 'same', 'replicate'));
%% Little excurse to the dimensions
% The image is always set in [row, column, z] dimensionsen. When we are
% working with axis [x,y,z] x = column, y = row and z = z. fitEllipsoid is
% working on the axis. So we get a center and a radii that depends on the
% axis and not on the image itself. So if we compute a sphere in the axis
% we can just use center and radii as it is. but if we want to visualize it
% in the image we need to permute the dimensions. So we can just work with
% the the output of fitEllipsoid on our sphere etc. But we need to be
% carefull when we use interp3 with landmark. landmark is the segmentation
% of the gfp channel. So it is in the same dimensions as the other images.
% We dont need to care about the resolution now because it is the same for
% x and y. 
% centCoords gives us the centroids of the cells in the image. It is
% computed with regionprops. This gives us the right centroids with the
% right order. So we can just use it for our axial representation.
%% Estimate embryo shape by fitting ellipsoid to sharp areas

[center radii axes v] = fitEllipsoid(sharp_areas, resolution);

%% Segment GFP landmark

landmark = segmentGFP(gfp_resized, resolution);

%% experimental code for rescaling data with different sizes 
% (some channel work with even less resolution)

% % delete old variable
% clear gfp_resized;
% % rescale gfp data and gfp landmark to higher resolution
% for i=1:size(data.Dapi,3)
%  landmark(:,:,i) = imresize(landmark_resized(:,:,i), size(dapi_resized(:,:,1)), 'nearest');
%  gfp_resized(:,:,i) = imresize(data.GFP(:,:,i), scale);
% end

%% segment stem cells in mCherry channel

% segment cells
[cells,centCoords] = segmentCells( mCherry_resized, resolution );

%% transform GFP on embryo shape onto unit sphere

% sample original space
mind = [0 0 0]; maxd = size(landmark) .* resolution;

%% experimental code for meshgrid with different resolution
%nsteps = maxd*0.2;
%step = ( maxd - mind ) ./ nsteps;
%[ X, Y, Z ] = meshgrid( linspace( mind(2) - step(2), maxd(2) + step(2), nsteps(2) ), linspace( mind(1) - step(1), maxd(1) + step(1), nsteps(1) ), linspace( mind(3) - step(3), maxd(3) + step(3), nsteps(3) ) );

%% create a meshgrid with same resolution as data
[ X, Y, Z ] = meshgrid( linspace( mind(2), maxd(2), size(landmark,2) ), linspace( mind(1), maxd(1), size(landmark,1) ), linspace( mind(3), maxd(3), size(landmark,3) ) );

%% experimental code to transform data using ellipsoid equation
% [ x_coarse, y_coarse, z_coarse] = meshgrid( linspace( mind(2) - step(2), maxd(2) + step(2), size(landmark,2) ), linspace( mind(1) - step(1), maxd(1) + step(1), size(landmark,1) ), linspace( mind(3) - step(3), maxd(3) + step(3), size(landmark,3) ) );
% Ellipsoid = v(1) *X.*X +   v(2) * Y.*Y + v(3) * Z.*Z + ...
%     2*v(4) *X.*Y + 2*v(5)*X.*Z + 2*v(6) * Y.*Z + ...
%     2*v(7) *X    + 2*v(8)*Y    + 2*v(9) * Z -1;
% % interpolate data
% landmark_fine = interp3(x_coarse, y_coarse, z_coarse, landmark, X, Y, Z, 'nearest');  
%validGFP = landmark_fine .* (abs(Ellipsoid) < 0.01);
% visualize and save result in 3D
%renderGFPsurface(Ellipsoid, landmark_fine, [1 1 1],X,Y,Z)

%% specify transformation matrix based on orientation and length of axis

scale_matrix = eye(3);
scale_matrix(1) = 1/radii(1);
scale_matrix(5) = 1/radii(2);
scale_matrix(9) = 1/radii(3);
rotation_matrix = axes';
transform = scale_matrix * rotation_matrix;

%% experimental code for sampling unit cube as 3D voxel grid
%mind = [-1 -1 -1]; maxd = [1 1 1];
%nsteps = [64 64 64];
%step = ( maxd - mind ) ./ nsteps;
%[Xc Yc Zc] = meshgrid( linspace( mind(2) - step(2), maxd(2) + step(2), nsteps(2) ), linspace( mind(1) - step(1), maxd(1) + step(1), nsteps(1) ), linspace( mind(3) - step(3), maxd(3) + step(3), nsteps(3) ));

%% sample surface of unit sphere by parametrization
samples = 64;
[alpha, beta] = meshgrid(linspace(pi,2*pi,samples/2), linspace(0,2*pi,samples)); % TODO: only one time 2*pi!
Zs = cos(alpha) .* sin(beta);
Xs = sin(alpha) .* sin(beta);
Ys = cos(beta);

% determine position of spherical points in original space

[Xs_t,Ys_t,Zs_t] = transformUnitSphere3D(Xs,Ys,Zs,scale_matrix,rotation_matrix,center);

% interpolate signal on unit sphere transformed to original space
GFPOnSphere = interp3(X, Y, Z, landmark, Xs_t, Ys_t, Zs_t,'nearest');

%% transform segmented cells on new positions within unit sphere

% sample unit cube as 3D voxel grid 
[Xc, Yc, Zc] = meshgrid(linspace(-1,1,samples), linspace(-1,1,samples), linspace(-1,1,samples));

% determine position of points in unit cube in original space

[Xc_t,Yc_t,Zc_t] = transformUnitCube3D(Xc,Yc,Zc,scale_matrix,rotation_matrix,center);

% interpolate signal in unit cube transformed to original space

CellsInSphere = interp3(X, Y, Z, cells, Xc_t, Yc_t, Zc_t,'nearest');
CellsInSphere(isnan(CellsInSphere)) = 0;

%% Registration

% Get coordinates of the cells

% Fit Coordinates to real resolution

centCoords = diag(resolution)*centCoords;

% Transform the coordinates into the sphere. With scaling and rotating.
centCoords(1,:) = centCoords(1,:)-center(1);
centCoords(2,:) = centCoords(2,:)-center(2);
centCoords(3,:) = centCoords(3,:)-center(3);
centCoords = transform*centCoords;


% Regression

data = [(round(Xs(GFPOnSphere == 1 & Zs <= 0)*10^10)/10^10)';...
    (round(Ys(GFPOnSphere == 1 & Zs <= 0)*10^10)/10^10)';...
    (round(Zs(GFPOnSphere == 1 & Zs <= 0)*10^10)/10^10)'];
data = unique(data','rows')';
[pstar,vstar] = sphericalRegression3D(data,[11;0;0],[0;0;-1]);
%%
% 
% # ITEM1
% # ITEM2
% 


% Registration and transformation



%% visualize results


figure;
renderCellsInSphere(CellsInSphere,Xc,Yc,Zc);
hold on;
T = 0:0.01:1;
    G = geodesicFun(pstar,vstar);
    regressionLine = G(T);
    scatter3(pstar(1),pstar(2),pstar(3));
   
    quiver3(pstar(1),pstar(2),pstar(3),vstar(1)/norm(vstar),vstar(2)/norm(vstar),vstar(3)/norm(vstar));
    plot3(regressionLine(1,:),regressionLine(2,:),regressionLine(3,:),'r');
    plot3(data(1,1),data(2,1),data(3,1),'o')
    plot3(data(1,end),data(2,end),data(3,end),'o')
    xlim([-1,1]);
    ylim([-1,1]);
    zlim([-1,1]);
    %plot3(x,y,z);
    scatter3(data(1,:),data(2,:),data(3,:),'*')

grid on;
scatter3(centCoords(1,:),centCoords(2,:),centCoords(3,:));
scatter3(Xs(:), Ys(:), Zs(:),10,[0 1 0]);
scatter3(Xs(GFPOnSphere == 1 & Zs <= 0), Ys(GFPOnSphere == 1 & Zs <= 0), Zs(GFPOnSphere == 1 & Zs <= 0),50,[1 0 0]); 
hold off;
axis vis3d equal;
view([-37.5, -75])
##### SOURCE END #####
--></body></html>